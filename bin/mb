#!/bin/bash

set -e

nephbin="$(dirname "$(readlink -f "$0")")"
. "$nephbin"/lib/util.sh
. ~/.bashrc

cd "$MOZPATH"

args=()
parseopts() {
    while [ $# -gt 0 ]; do
        arg="$1"
        shift
        case "$arg" in
            '--no-mach') # Don't use mach
                nomach=1
                ;;
            '--cgroup') # Use cgroup hooks
                cgroup=1
                ;;
            '--no-distcc') # Don't use distcc
                nodistcc=1
                ;;
            '--no-buildtree') # Build against current tree, without build-tree
                nobuildtree=1 # magic
                ;;
            '-b') # Only sync buildtree, don't build anything
                onlysyncbuild=1
                ;;
            '--only-distcc') # Don't use local cpus
                onlydistcc=1
                ;;
            '--clobber') # Try to make clobber the objdir
                clobber=1
                ;;
            '--nuke') # Delete objdir first
                nuke=1
                ;;
            '--branch')
                explicitbranch="$1"
                shift
                ;;
            '--no-ramdisk') # Don't put build tree / objdir in ramdisks
                noramdisk=1
                ;;
            '-c') # Explicitly reconfigure tree
                configure=1
                ;;
            '-f') # Override clobber check
                force=1
                ;;
            '-j') # Make jobs
                makejobs="$1"
                shift
                ;;
            '-n') # Attempt a incremental build with ninja
                ninja=1
                ;;
            '--no-hacky') # Don't apply hackymake to builds
                nohacky=1
                ;;
            '-v')
                verbose=1
                ;;
            '-p') # make package when finished
                package=1
                ;;
            '--cpufreq') # Jump to performance cpufreq
                cpufreq=1
                ;;
            '--')
                args=("${args[@]}" "$@")
                break
                ;;
            *)
                [ "${arg#-}" = "$arg" ] || die "Unexpected argument: $arg"
                args[${#args[@]}]="$arg"
                ;;
        esac
    done
}
parsed="$(getopt -n mb -l no-mach,cgroup,no-distcc,no-ramdisk,no-buildtree,no-hacky,only-distcc,clobber,nuke,cpufreq,branch: -o nj:bcfvp -- "$@")"
eval parseopts $parsed

#
# Defaults & Sanity
#

[ ! -z "$noramdisk" ] || ramdisk="/tmp/mb-ramdisk-$USER"

if [ ! -z "$nodistcc" ] && [ ! -z "$onlydistcc" ]; then
    die "--no-distcc and --only-distcc are mutually exclusive"
fi

if [ -z "$MOZOBJ" ] || [ -z "$MOZTREE" ] || [ -z "$MOZCONFIG" ] || \
    [ ! -d "$MOZTREE" ] || [ ! -f "$MOZCONFIG" ]; then
    die "moz environment is not properly configured :("
fi

if [ ! -f "$MOZTREE/mach" ] && [ -z "$nomach" ]; then
    die "This tree has no mach, but --no-mach was not specified"
fi

[ -f "$MOZTREE/client.mk" ] || die "Tree \"$MOZTREE\" doesn't have a client.mk..."

if [ -d "$MOZOBJ" ] && [ ! -d "$MOZOBJ/.hacky" ] && [ -z "$nohacky" ] &&
   [ -z "$nuke" ]; then
  die "Current objdir built without hacky.mk, use --nuke or --no-hacky"
fi

if [ -d "$MOZOBJ/.hacky" ] && [ ! -z "$nohacky" ] && [ -z "$nuke" ]; then
  die "Current objdir has hacky.mk, building without hacky.mk requires --nuke"
fi

if [ ! -z "$ninja" ]; then
  [ -f "$MOZOBJ/Makefile" ] || die "Tree isn't fully built, can't ninja"
  [ -f "$MOZOBJ/build.ninja" ] || die "No ninja - tree built without hacky.mk"
  [ -z "$clobber" ] || die "Can't clobber and use ninja"
  [ -z "$nuke" ] || die "Can't nuke and use ninja"
  [ -z "$configure" ] || die "Can't reconfigure and use ninja"
  [ -z "$force" ] || die "-f doesn't make sense when using ninja"
  [ -z "$nohacky" ] || die "--no-hacky and ninja don't make sense"
fi

#
# Handle --no-buildtree
#

if [ ! -z "$nobuildtree" ]; then
  MOZBUILDTREE="$MOZTREE"
fi

#
# Make environment
#

# We handle clobbering when desired, so disable mach/client.mk's autoclobber
export NO_AUTOCLOBBER=1

PYTHON="py2e python"
MACH="py2e ./mach"
MAKE="py2e make"
NINJA="py2e ninja"
[ -z "$verbose" ] && MAKE="$MAKE --silent"

#
# Setup cpufreq and cgroup
#

trap=""
if [ ! -z "$cpufreq" ]; then
    estat "Boosting cpufreq"
    trap="cpufreq-selector -c all -g ondemand"
    cpufreq-selector -c all -g performance
fi

if [ ! -z "$cgroup" ]; then
    if [ ! -f /sys/fs/cgroup/cpu/tasks ]; then
        ewarn "No cgroup"
        sleep 2
    else
        lpcg
        [ -z "$trap" ] || trap="$trap; "
        trap="${trap}dcg"
    fi
fi

[ -z "$trap" ] || trap "$trap" EXIT

#
# DistCC?
#

if [ -z "$nodistcc" ]; then
    MACH="pump $MACH"
    MAKE="pump $MAKE"
    if [ -f "$nephbin/../priv/distcc.conf" ]; then
      [ -z "$onlydistcc" ] || export NEPH_DISTCC_NOLOCAL=1
      estat "Found distcc.conf"
      source "$nephbin/../priv/distcc.conf"
    fi
    if [ -z "${DISTCC_HOSTS}${DISTCC_POTENTIAL_HOSTS}" ]; then
      eerr "No DISTCC_HOSTS or DISTCC_POTENTIAL_HOSTS"
      die  "Set these or use --no-distcc"
    fi
    export MAKE_JOBS=$(( $(distcc -j) * 2 ))
    estat "distcc configured with $MAKE_JOBS jobs: "$DISTCC_HOSTS
fi

[ -z "$makejobs" ] || export MAKE_JOBS="$makejobs"

#
# Nuke or clobber if requested
#

if [ ! -z "$nuke" ]; then
  estat "Nuking build"
  [ -z "$ramdisk" ] || cmd rm -rf "$ramdisk"
  cmd rm -rf "$MOZOBJ"
  # If we're using a ramdisk, --nuke should kill the (potentially-non-ramdisk)
  # build tree
  [ -z "$ramdisk" ] || cmd rm -rf "$MOZBUILDTREE"
elif [ -d "$MOZOBJ" ] && [ ! -z "$force" ]; then
  estat "Overriding clobber"
  touch "$MOZOBJ"/CLOBBER
fi

#
# Setup ramdisk maybe
#

# Kill dead ramdisk symlinks
[ ! -L "$MOZBUILDTREE" ] || [ -d "$MOZBUILDTREE" ] || rm "$MOZBUILDTREE"
[ ! -L "$MOZOBJ" ] || [ -d "$MOZOBJ" ] || rm "$MOZOBJ"

if [ ! -z "$ramdisk" ]; then
  # Check for existing, non-ramdisk directories
  if [ -e "$MOZOBJ" ] && [ ! -L "$MOZOBJ" ]; then
    die "Non-ramdisk objdir exists. Use --no-ramdisk or --nuke"
  fi
  if [ -e "$MOZBUILDTREE" ] && [ ! -L "$MOZBUILDTREE" ]; then
    die "Non-ramdisk build tree exists, use --nuke or --no-ramdisk"
  fi

  # Setup ramdisk
  if [ ! -d "$ramdisk" ]; then
    ( umask 077 && cmd mkdir "$ramdisk" )
    ( cd "$ramdisk" && ln -s "$MOZPATH/cfg" )
  fi
  if [ ! -d "$MOZOBJ" ]; then
    cmd mkdir "$ramdisk/$MOZOBJ"
    cmd ln -s "$ramdisk/$MOZOBJ"
  fi
else
  # Not using a ramdisk, make sure one isn't setup
  if [ -L "$MOZBUILDTREE" ] || [ -L "$MOZOBJ" ]; then
    die "--no-ramdisk given, but current build is on a ramdisk. Use --nuke"
  fi
fi

#
# If configured at this point, check that it is against the right tree
#

if [ -f "$MOZOBJ/Makefile" ]; then
  configured_tree="$(egrep '^topsrcdir' "$MOZOBJ/Makefile" | awk '{ print $NF }')"
  configured_tree="$(readlink -f "$configured_tree")"
  expected_tree="$(readlink -f "$MOZBUILDTREE")"
  if [ "$configured_tree" != "$expected_tree" ]; then
    die "Build directory is configured against the wrong tree, use --clobber or --nuke"
  fi
fi

#
# Setup build tree if needed
#

if [ "$MOZBUILDTREE" != "$MOZTREE" ]; then
  # Create a commit via |git stash create| that represents our working tree
  # state, and check it out in MOZBUILDTREE to build.

  # MOZBUILDTREE will always be on this branch, which is our current branch + a
  # working tree commit. This lets us do things like |git diff build/moz-git| to
  # compare against our last build, and have a reflog of working directory
  # changes we built at.
  branch="build/$MOZBUILDTREE"

  # The ref our working tree is based on
  if [ -z "$explicitbranch" ]; then
    buildref=HEAD
  else
    buildref="$explicitbranch"
    no_worktree=1
  fi
  buildref="$(cd "$MOZTREE" && git rev-parse "$buildref")"
  [ ! -z "$buildref" ] || die "Failed to parse $buildref"

  # Make sure build branch exists
  if [ ! -d "$MOZBUILDTREE" ]; then
    estat "Creating new $MOZBUILDTREE"
    ( cd "$MOZTREE" && cmd git branch -f "$branch" "$buildref" )
    if [ -z "$ramdisk" ]; then
      /usr/share/git/workdir/git-new-workdir "$MOZTREE" "$MOZBUILDTREE" "$branch"
    else
      /usr/share/git/workdir/git-new-workdir "$MOZTREE" \
                                             "$ramdisk/$MOZBUILDTREE" "$branch"
      cmd ln -s "$ramdisk/$MOZBUILDTREE"
    fi
  fi

  # Make a staging tree or reset it. We use a staging tree so we can avoid
  # touching all uncommited files every build by blowing away the previous build
  # commit. It's possible to do this with two trees, but much uglier.
  if [ ! -d "mb-staging" ]; then
    estat "Creating mb-staging stage tree"
    /usr/share/git/workdir/git-new-workdir "$MOZTREE" mb-staging "$buildref"
  else
    (
      cd mb-staging
      git checkout --detach -f "$buildref" 2>/dev/null
    )
  fi

  (
    cd mb-staging
    if [[ ! "$no_worktree" ]]; then
      # Copy working tree state to staging with |stash create| and hardlinking
      # untracked files over
      worktree_stash="$(cd "$MOZPATH/$MOZTREE" && cmd git stash create)"

      if [ ! -z "$worktree_stash" ]; then
        cmd git stash apply "$worktree_stash" >/dev/null
      fi
      while IFS="" read -r file; do
        cmd mkdir -p "$(dirname "$file")"
        cmd ln "$MOZPATH/$MOZTREE/$file" "$file"
      done < <(cd "$MOZPATH/$MOZTREE" && git ls-files -o --exclude-standard)
      git add -A
    fi
    cmd git commit --allow-empty -m "BUILD @ $(date)" >/dev/null
  )
  buildref="$(cd mb-staging && git rev-parse HEAD)"
  (
    # Finally update our build tree to this ref (keeps a helpful build/whatever
    # reflog)
    cd "$MOZBUILDTREE"
    # Should already be on this branch, but we definitely don't want to reset
    # another branch if we accidentally messed with this workdir
    cmd git checkout -f "$branch" 2>/dev/null
    oldref="$(git rev-parse HEAD)"
    if [ -z "$nohacky" ]; then
      cmd git reset --hard "${buildref}^"
      cmd "$MOZPATH/hacky.mk/hackify" "$PWD" >/dev/null
      cmd git add -A
      cmd git commit -m "HACKIFY FOR BUILD @ $(date)" >/dev/null
      cmd git cherry-pick "$buildref" --allow-empty
    else
      ewarn Not applying hacky.mk
      cmd git reset --hard "$buildref"
    fi
    PAGER="" cmd git diff "$oldref" --stat
  )
fi

[ -z "$onlysyncbuild" ] || exit 0

#
# Explicit configure if requested
#

if [ ! -z "$configure" ]; then
    if [ -z "$nomach" ]; then
        estat "-f specified, nuking config.status to force reconfigure"
        cmd rm -vf "$MOZOBJ"/config.status
    else
        estat "Not using mach, explicitly reconfiguring tree (-f)"
        (
            cd "$MOZBUILDTREE"
            cmd $MAKE -f client.mk configure
        )
    fi
fi

#
# Do the build
#
(
  cmd cd "$MOZBUILDTREE"
  if [ ! -z "$ninja" ]; then
    (
      cd "$MOZPATH/$MOZOBJ"
      time cmd $NINJA
    )
  elif [ -z "$nomach" ]; then
      estat "Building with mach"
      cmd $MACH build "${args[@]}"
  else
      ewarn "Not using mach"
      [ "${#args[@]}" -eq 0 ] || die "Building directories not supported w/o mach"
      time cmd $MAKE -f client.mk && estat "Make succeeded"
  fi
  if [ -z "$ninja$nohacky" ]; then
    (
      cmd cd "$MOZPATH/$MOZOBJ"
      # Also provided by nephscripts
      cmd hacky_purge_missing_deps
      cmd $PYTHON "$MOZPATH/$MOZBUILDTREE/tools/hackymake/hackypost.py" "."
    )
  fi
)

if [ ! -z "$package" ]; then
    cmd cd "$MOZPATH/$MOZOBJ"
    cmd $MAKE package
    cmd $MAKE package-tests
    estat "Package succeeded"
fi
